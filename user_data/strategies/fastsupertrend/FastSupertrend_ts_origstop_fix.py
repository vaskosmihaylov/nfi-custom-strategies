"""
Supertrend strategy:
* Description: Generate a 3 supertrend indicators for 'buy' strategies & 3 supertrend indicators for 'sell' strategies
               Buys if the 3 'buy' indicators are 'up'
               Sells if the 3 'sell' indicators are 'down'
* Author: @juankysoriano (Juan Carlos Soriano)
* github: https://github.com/juankysoriano/
*** NOTE: This Supertrend strategy is just one of many possible strategies using `Supertrend` as indicator. It should on any case used at your own risk.
          It comes with at least a couple of caveats:
            1. The implementation for the `supertrend` indicator is based on the following discussion: https://github.com/freqtrade/freqtrade-strategies/issues/30 . Concretelly https://github.com/freqtrade/freqtrade-strategies/issues/30#issuecomment-853042401
            2. The implementation for `supertrend` on this strategy is not validated; meaning this that is not proven to match the results by the paper where it was originally introduced or any other trusted academic resources
"""

import logging
import numpy as np
import pandas as pd
import talib.abstract as ta
from freqtrade.strategy import IStrategy, IntParameter
from pandas import DataFrame

log = logging.getLogger(__name__)

class FastSupertrend_ts_origstop_fix(IStrategy):
    # Buy params, Sell params, ROI, Stoploss and Trailing Stop are values generated by 'freqtrade hyperopt --strategy Supertrend --hyperopt-loss ShortTradeDurHyperOptLoss --timerange=20210101- --timeframe=1h --spaces all'
    # It's encourage you find the values that better suites your needs and risk management strategies

    INTERFACE_VERSION: int = 3
    # Buy hyperspace params:
    buy_params = {
        "buy_m1": 4,
        "buy_m2": 7,
        "buy_m3": 1,
        "buy_p1": 8,
        "buy_p2": 9,
        "buy_p3": 8,
    }

    # Sell hyperspace params:
    sell_params = {
        "sell_m1": 1,
        "sell_m2": 3,
        "sell_m3": 6,
        "sell_p1": 16,
        "sell_p2": 18,
        "sell_p3": 18,
    }

    # ROI table:
    #minimal_roi = {"0": 0.1, "120": 0.025}
    minimal_roi = {"0": 1}

    # Stoploss:
    stoploss = -0.1
    can_short = True

    # Trailing stop:
    trailing_stop = False
    trailing_stop_positive = 0.001
    trailing_stop_positive_offset = 0.02
    trailing_only_offset_is_reached = False

    timeframe = '1h'

    startup_candle_count = 26

    buy_m1 = IntParameter(1, 7, default=1, space='buy', load=True, optimize=True)
    buy_m2 = IntParameter(1, 7, default=3, space='buy', load=True, optimize=True)
    buy_m3 = IntParameter(1, 7, default=4, space='buy', load=True, optimize=True)
    buy_p1 = IntParameter(7, 21, default=14, space='buy', load=True, optimize=True)
    buy_p2 = IntParameter(7, 21, default=10, space='buy', load=True, optimize=True)
    buy_p3 = IntParameter(7, 21, default=10, space='buy', load=True, optimize=True)

    sell_m1 = IntParameter(1, 7, default=1, space='sell', load=True, optimize=True)
    sell_m2 = IntParameter(1, 7, default=3, space='sell', load=True, optimize=True)
    sell_m3 = IntParameter(1, 7, default=4, space='sell', load=True, optimize=True)
    sell_p1 = IntParameter(7, 21, default=14, space='sell', load=True, optimize=True)
    sell_p2 = IntParameter(7, 21, default=10, space='sell', load=True, optimize=True)
    sell_p3 = IntParameter(7, 21, default=10, space='sell', load=True, optimize=True)

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe['supertrend_1_buy'] = self.supertrend(dataframe, self.buy_m1.value, int(self.buy_p1.value))['STX']
        dataframe['supertrend_2_buy'] = self.supertrend(dataframe, self.buy_m2.value, int(self.buy_p2.value))['STX']
        dataframe['supertrend_3_buy'] = self.supertrend(dataframe, self.buy_m3.value, int(self.buy_p3.value))['STX']
        dataframe['supertrend_1_sell'] = self.supertrend(dataframe, self.sell_m1.value, int(self.sell_p1.value))['STX']
        dataframe['supertrend_2_sell'] = self.supertrend(dataframe, self.sell_m2.value, int(self.sell_p2.value))['STX']
        dataframe['supertrend_3_sell'] = self.supertrend(dataframe, self.sell_m3.value, int(self.sell_p3.value))['STX']

        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:

        dataframe.loc[
            (
               (dataframe[f'supertrend_1_buy'] == 'up') &
               (dataframe[f'supertrend_2_buy'] == 'up') &
               (dataframe[f'supertrend_3_buy'] == 'up') &
               (dataframe['volume'] > 0)
        ),
            'enter_long'] = 1

        dataframe.loc[
            (
               (dataframe[f'supertrend_1_sell'] == 'down') &
               (dataframe[f'supertrend_2_sell'] == 'down') &
               (dataframe[f'supertrend_3_sell'] == 'down') &
               (dataframe['volume'] > 0)
        ),
            'enter_short'] = 1

        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            (
               (dataframe[f'supertrend_2_buy'] == 'down')
            ),
            'exit_long'] = 1

        dataframe.loc[
            (
               (dataframe[f'supertrend_2_buy'] == 'up')
            ),
            'exit_short'] = 1

        return dataframe

    """
        Supertrend Indicator; adapted for freqtrade
        from: https://github.com/freqtrade/freqtrade-strategies/issues/30
    """
    def supertrend(self, dataframe: DataFrame, multiplier: float, period: int) -> DataFrame:
        """
        Supertrend Indicator implementation optimized for performance and NumPy 2.0+ compatibility.
        
        Args:
            dataframe: Input price data
            multiplier: ATR multiplier for band calculation
            period: Period for ATR calculation
            
        Returns:
            DataFrame with ST (Supertrend values) and STX (trend direction)
        """
        try:
            if dataframe.empty or len(dataframe) < period:
                log.warning(f"Insufficient data for Supertrend calculation (need {period}, got {len(dataframe)})")
                return DataFrame(index=dataframe.index, data={'ST': np.nan, 'STX': 'neutral'})
                
            df = dataframe.copy()
            last_row = len(df)

            # Calculate True Range and Average True Range
            df['TR'] = ta.TRANGE(df)
            df['ATR'] = ta.SMA(df['TR'], period)

            st = f'ST_{period}_{multiplier}'
            stx = f'STX_{period}_{multiplier}'

            # Compute basic upper and lower bands (vectorized)
            hl2 = (df['high'] + df['low']) / 2
            atr_mult = multiplier * df['ATR']
            BASIC_UB = (hl2 + atr_mult).values
            BASIC_LB = (hl2 - atr_mult).values

            # Initialize arrays
            FINAL_UB = np.zeros(last_row)
            FINAL_LB = np.zeros(last_row)
            ST = np.zeros(last_row)
            CLOSE = df['close'].values

            # Compute final upper and lower bands (optimized)
            for i in range(period, last_row):
                FINAL_UB[i] = (BASIC_UB[i] if BASIC_UB[i] < FINAL_UB[i - 1] or 
                              CLOSE[i - 1] > FINAL_UB[i - 1] else FINAL_UB[i - 1])
                FINAL_LB[i] = (BASIC_LB[i] if BASIC_LB[i] > FINAL_LB[i - 1] or 
                              CLOSE[i - 1] < FINAL_LB[i - 1] else FINAL_LB[i - 1])

            # Set the Supertrend values (optimized logic)
            for i in range(period, last_row):
                if ST[i - 1] == FINAL_UB[i - 1]:
                    ST[i] = FINAL_LB[i] if CLOSE[i] > FINAL_UB[i] else FINAL_UB[i]
                else:  # ST[i - 1] == FINAL_LB[i - 1]
                    ST[i] = FINAL_UB[i] if CLOSE[i] < FINAL_LB[i] else FINAL_LB[i]

            df[st] = ST

            # Mark the trend direction (NumPy 2.0+ compatible)
            df[stx] = np.where(
                df[st] > 0.00,
                np.where(df['close'] < df[st], 'down', 'up'),
                'neutral'  # Changed from np.nan to 'neutral' for clarity
            )

            df.fillna(0, inplace=True)

            return DataFrame(index=df.index, data={
                'ST': df[st],
                'STX': df[stx]
            })
            
        except Exception as e:
            log.error(f"Error calculating Supertrend: {str(e)}")
            return DataFrame(index=dataframe.index, data={'ST': np.nan, 'STX': 'neutral'})

    @property
    def plot_config(self):
        plot_config = {
            'main_plot': {
            },
            'subplots':{
                'entry': {
                    'supertrend_1_buy': {'color': 'rgba(0,255,0,1)'},
                    'supertrend_2_buy': {'color': 'rgba(0,205,0,1)'},
                    'supertrend_3_buy': {'color': 'rgba(0,155,0,1)'},
                },
                'exit': {
                    'supertrend_1_sell': {'color': 'rgba(255,0,0,1)'},
                    'supertrend_2_sell': {'color': 'rgba(205,0,0,1)'},
                    'supertrend_3_sell': {'color': 'rgba(155,0,0,1)'},
                },
            },
        }
        return plot_config
